from __future__ import absolute_import, unicode_literals, with_statement

"""
This type stub file was generated by pyright.
"""

import contextlib
from re import Pattern
from typing import Generator, Any, Literal, TypeVar
from .context import pdtContext
from datetime import timezone, datetime, date, time
from time import struct_time

versionType = Literal[0, 1, 2, 3]
StructTime = struct_time | datetime | date | time
StructTimeT = TypeVar('StructTimeT', bound='StructTime')
SourceTimeT = TypeVar('SourceTimeT', bound='datetime | date | time | str')
"""parsedatetime

Parse human-readable date/time text.

Requires Python 2.7 or later
"""
VERSION_FLAG_STYLE: Literal[1] = ...
VERSION_CONTEXT_STYLE: Literal[2] = ...

class Calendar:
    """
    A collection of routines to input, parse and manipulate date and times.
    The text can either be 'normal' date values or it can be human readable.
    """

    def __init__(self, constants: Constants = ..., version: versionType = ...) -> None:
        """
        Default constructor for the L{Calendar} class.

        @type  constants: object
        @param constants: Instance of the class L{Constants}
        @type  version:   integer
        @param version:   Default style version of current Calendar instance.
                          Valid value can be 1 (L{VERSION_FLAG_STYLE}) or
                          2 (L{VERSION_CONTEXT_STYLE}). See L{parse()}.

        @rtype:  object
        @return: L{Calendar} instance
        """
        ...
    @contextlib.contextmanager
    def context(self) -> Generator[pdtContext, None, None]: ...
    @property
    def currentContext(self) -> Any: ...
    def parseDate(self, dateString: str, sourceTime: StructTimeT = None) -> StructTimeT:
        """
        Parse short-form date strings::

            '05/28/2006' or '04.21'

        @type  dateString: string
        @param dateString: text to convert to a C{datetime}
        @type  sourceTime:     StructTimeT
        @param sourceTime:     C{StructTimeT} value to use as the base

        @rtype:  StructTimeT
        @return: calculated C{StructTimeT} value of dateString
        """
        ...
    def parseDateText(self, dateString: str, sourceTime: StructTimeT = None) -> StructTimeT:
        """
        Parse long-form date strings::

            'May 31st, 2006'
            'Jan 1st'
            'July 2006'

        @type  dateString: string
        @param dateString: text to convert to a datetime
        @type  sourceTime:     StructTimeT
        @param sourceTime:     C{StructTimeT} value to use as the base

        @rtype:  StructTimeT
        @return: calculated C{StructTimeT} value of dateString
        """
        ...
    def evalRanges(self, datetimeString: str, sourceTime: StructTime = ...) -> tuple[datetime, datetime, int]:
        """
        Evaluate the C{datetimeString} text and determine if
        it represents a date or time range.

        @type  datetimeString: string
        @param datetimeString: datetime text to evaluate
        @type  sourceTime:     StructTimeT
        @param sourceTime:     C{StructTimeT} value to use as the base

        @rtype:  tuple
        @return: tuple of: start datetime, end datetime and the invalid flag
        """
        ...
    def parseDT(
        self,
        datetimeString: str,
        sourceTime: StructTimeT | None = None,
        tzinfo: timezone = ...,
        version: versionType = ...,
    ) -> tuple[StructTimeT, pdtContext]:
        """
        C{datetimeString} is as C{.parse}, C{sourceTime} has the same semantic
        meaning as C{.parse}, but now also accepts datetime objects.  C{tzinfo}
        accepts a tzinfo object.  It is advisable to use pytz.


        @type  datetimeString: string
        @param datetimeString: date/time text to evaluate
        @type  sourceTime:     StructTimeT, datetime, date, time
        @param sourceTime:     time value to use as the base
        @type  tzinfo:         tzinfo
        @param tzinfo:         Timezone to apply to generated datetime objs.
        @type  version:        integer
        @param version:        style version, default will use L{Calendar}
                               parameter version value

        @rtype:  tuple
        @return: tuple of: modified C{sourceTime} and the result flag/context

        see .parse for return code details.
        """
        ...
    def parse(
        self, datetimeString: str, sourceTime: StructTimeT = None, version: versionType = ...
    ) -> tuple[StructTimeT, pdtContext] | tuple[StructTimeT, int]:
        """
        Splits the given C{datetimeString} into tokens, finds the regex
        patterns that match and then calculates a C{StructTimeT} value from
        the chunks.

        If C{sourceTime} is given then the C{StructTimeT} value will be
        calculated from that value, otherwise from the current date/time.

        If the C{datetimeString} is parsed and date/time value found, then::

            If C{version} equals to L{VERSION_FLAG_STYLE}, the second item of
            the returned tuple will be a flag to let you know what kind of
            C{StructTimeT} value is being returned::

                0 = not parsed at all
                1 = parsed as a C{date}
                2 = parsed as a C{time}
                3 = parsed as a C{datetime}

            If C{version} equals to L{VERSION_CONTEXT_STYLE}, the second value
            will be an instance of L{pdtContext}

        @type  datetimeString: string
        @param datetimeString: date/time text to evaluate
        @type  sourceTime:     StructTimeT
        @param sourceTime:     C{StructTimeT} value to use as the base
        @type  version:        integer
        @param version:        style version, default will use L{Calendar}
                               parameter version value

        @rtype:  tuple
        @return: tuple of: modified C{sourceTime} and the result flag/context
        """
        ...
    def inc(self, source: StructTime, month: int | float | None = ..., year: int | float | None = ...) -> datetime:
        """
        Takes the given C{source} date, or current date if none is
        passed, and increments it according to the values passed in
        by month and/or year.

        This routine is needed because Python's C{timedelta()} function
        does not allow for month or year increments.

        @type  source: StructTimeT
        @param source: C{StructTimeT} value to increment
        @type  month:  float or integer
        @param month:  optional number of months to increment
        @type  year:   float or integer
        @param year:   optional number of years to increment

        @rtype:  datetime
        @return: C{source} incremented by the number of months and/or years
        """
        ...
    def nlp(
        self, inputString: str, sourceTime: StructTime = ..., version: versionType = ...
    ) -> tuple[tuple[datetime, pdtContext, int, int, str]] | None:
        """Utilizes parse() after making judgements about what datetime
        information belongs together.

        It makes logical groupings based on proximity and returns a parsed
        datetime for each matched grouping of datetime text, along with
        location info within the given inputString.

        @type  inputString: string
        @param inputString: natural language text to evaluate
        @type  sourceTime:  StructTimeT
        @param sourceTime:  C{StructTimeT} value to use as the base
        @type  version:     integer
        @param version:     style version, default will use L{Calendar}
                            parameter version value

        @rtype:  tuple or None
        @return: tuple of tuples in the format (parsed_datetime as
                 datetime.datetime, flags as int, start_pos as int,
                 end_pos as int, matched_text as string) or None if there
                 were no matches
        """
        ...

class Constants:
    """
    Default set of constants for parsedatetime.

    If PyICU is present, then the class will first try to get PyICU
    to return a locale specified by C{localeID}.  If either C{localeID} is
    None or if the locale does not exist within PyICU, then each of the
    locales defined in C{fallbackLocales} is tried in order.

    If PyICU is not present or none of the specified locales can be used,
    then the class will initialize itself to the en_US locale.

    if PyICU is not present or not requested, only the locales defined by
    C{pdtLocales} will be searched.
    """

    def __init__(self, localeID: str = ..., usePyICU: bool = ..., fallbackLocales: list[str] = ...) -> None: ...
    def __getattr__(self, name: str) -> Pattern[str] | Any: ...
    def daysInMonth(self, month: int, year: int) -> None:
        """
        Take the given month (1-12) and a given year (4 digit) return
        the number of days in the month adjusting for leap year as needed
        """
        ...
    def getSource(self, sourceKey: str, sourceTime: str = ...) -> StructTime | None:
        """
        GetReturn a date/time tuple based on the giving source key
        and the corresponding key found in self.re_sources.

        The current time is used as the default and any specified
        item found in self.re_sources is inserted into the value
        and the generated dictionary is returned.
        """
        ...
